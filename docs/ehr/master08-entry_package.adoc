= Entry Package

== Design Principles

=== Information Ontology

All information which is created in the openEHR health record is expressed as an instance of a class in the entry package, containing the `ENTRY` class and a number of descendants. An `ENTRY` instance is logically a single 'clinical statement', and may be a single short narrative phrase, but may also contain a significant amount of data, e.g. a microbiology result, a psychiatric examination, a complex prescription. In terms of clinical content, the Entry classes are the most important in the openEHR EHR Information Model, since they define the semantics of all the 'hard' information in the record. They are intended to be archetyped, and in fact, archetypes for Entries make up the vast majority of important clinical archetypes defined.

The design of `entry` package is based on the Clinical Investigator Recording process and ontology, described in citenp:[Beale_Heard2007]. The process is shown in following figure.

[.text-center]
.Clinical Investigator Recording Process
image::{diagrams_uri}/clinical_investigator_process.png[id=clinical_investigator_process, align="center", width=80%]

This figure shows the cycle of information created by an iterative, problem solving process undertaken by a "clinical investigator system", which consists of health carers, and may include the patient (at points in time when the patient performs observational or therapeutic activities). Starting from the patient (right hand side of figure) observations are made, which lead to opinions on the part of the investigator, including assessment of the current situation, goals for a future situation, and plans for achieving the goals. Personal and published evidence and knowledge almost always play an important part in this process. The latter lead to instructions designed to help the patient achieve the goals. A complex or chronic problem may take numerous iterations - possibly a whole lifetime's worth - with each step being quite small, and future steps depending heavily on past progress. The role of the investigator (and associated agents) is normally filled by health care professionals, but may also be filled by the patient, or a guardian or associate of the patient. Indeed, this is what happens every time a person goes home from the pharmacy with prescribed medication to take at home.

The process illustrated in <<clinical_investigator_recording_process>> is a synthesis of the 'problem-oriented' approach of citenp:[Weed1969] and the "hypothetico-deductive model" of clinical reasoning described by citenp:[Elstein1978]. However, as pointed out in citenp:[Elstein_Schwarz2002], hypothesis-making and testing is not the only successful process used by clinical professionals - evidence shows that many (particularly those older and more experienced) rely on pattern recognition and direct retrieval of plans used previously with similar patients or prototype models. The investigator process is compatible with both cognitive approaches, since it does not say how opinions are formed, nor imply any specific number or size of iterations to bring the process to a conclusion. As such, the openEHR information model does not impose any process model, only the types of information used.

On the basis of this process, a Clinical Investigator Recording ontology is developed cite:[Beale_Heard2007], as shown below. From this ontology, the openEHR class model for Entries is derivde. The openEHR Entry class names are annotated next to their originating ontological categories.

[.text-center]
.The Clinical Investigator Recording (CIR) ontology
image::{diagrams_uri}/CIR_ontology.png[id=CIR_ontology, align="center", width=80%]

The key top-level categories in the ontology are 'care information' and 'administrative information'. The former encompasses all statements that might be recorded at any point during the care process, and consists of the major subcategories 'history', 'opinion' and 'instruction', which themselves correspond to the past, present and future in time (ISO TC215 uses the terms 'retrospective', 'current' and 'prospective'). The administrative information category covers information which is not generated by the care process proper, but relates to organising it, such as appointments and admissions. This information is not about care, but about the logistics of care being delivered. Categories that relate to the patient system as observed and understood are shown as white bubbles, while categories that relate to intervention into the patient system are shown as shaded. The opinion category has features of both passive analysis and active intervention.

There are two key justifications for using the ontology in <<CIR_ontology>> as a basis for class design. Firstly, although for all categories in the ontology there is a meaning for 'contextual' attributes of time, place, identity, reason and so on, each category has a different structure for these attributes. For example, time in the Observation category has a linear historical structure, whereas in Instruction it has a branching, potentially cyclic structure. The separation of types allows these contextual attributes to be modelled according to the type. Secondly, the separation of types provides a systematic solution to the so-called problem of "status" or "meaning modification" of clinical statement values, as described below.

=== Clinical Statement Status and Negation

A well-known problem in clinical information recording is the problem of assigning "status", including variants like "actual value of P" (P stands for some phenomenon), "family history of P", "risk of P", "fear of P", as well as negation of any of these, i.e. "not/no P", "no history of P" etc. A proper analysis of these so called statuses [4] shows that they are not "statuses" at all, but different categories of information as per the ontology. The common statement types mentioned here are mapped as follows:

* actual value of P -> Observation (of P);
* no/not P -> Observation (of excluded P or types of P, e.g. allergies).
* family history of P -> Evaluation (that patient is at risk of P);
* no family history of P -> Evaluation (that P is an excluded risk);
* risk of P -> Evaluation (that patient is at risk of P);
* no risk of P -> Evaluation (that patient is not at risk of P);
* fear of P -> Observation (of FEAR, with P mentioned in the description);

In general, negations of the kind mentioned above are handled by using "exclusion" archetypes for the appropriate Entry type. For example, "no allergies" can be modelled using an Evaluation archetype that describes which allergies are excluded for this patient.

Another set of statement types that can be confused in systems that do not properly model information categories concern interventions, e.g. "hip replacement (5 years ago)", "hip replacement (planned)", "hip replacement (ordered for next tuesday 10 am)". Ambiguity is removed here as well, with the use of the correct information categories, e.g. (I stands for an intervention):

* I (distant past/unmanaged/passively documented) -> Observation (of I present in patient);
* I (recent past) -> Action (of I having been done to/for patient);
* I (proposed) -> Evaluation, subtype Proposal (of I suggested/likely for patient);
* I (ordered) -> Instruction (of I for patient for some date in the future).

Related to the problem of clinical status is the need to differentiate between diagnoses that have been made in the present from those that were made in the past, and are reported by the patient. In openEHR, diagnosis and indeed all opinion category types are modelled as Evaluations, regardless of when they were made. Time information for diagnosis and other opinions is simply handled within the archetype for Evaluation, enabling a diagnosis (say of diabetes) that was made 15 years ago to have the same status as one made during the period when the EHR was actually operating, and the patient was under the care of the physician using it. Archetypes for the opinion categories tend to have quite a number of times, including "time first noticed", "time of onset", and so on. 

Correct use of the categories from the ontology is facilitated by using archetypes designed to map particular kinds of clinical statement to particular `ENTRY` subtypes. In a system where Entries are thus modelled, there will be no danger of incorrectly identifying the various kinds of Entries, as long as the Entry subtype, time, and certainty/negation are taken into account.

=== Standard Clinical Types of Data

Commonly used types of clinical information are directly representable using the openEHR Entry types. As described in the openEHR EHR IM, two kinds of Composition are identified: persistent and event. The persistent kind corresponds to information that characterises the patient in the long term, and is maintained by clinicians - it can be thought of as a proxy "model of the patient". Most of the the following are examples of Entry level data belonging inside persistent Compositions:

* _Basic information_ (dob, sex, height, weight, pregnant etc): recorded as Observations and/or Admin_entries;
* _Problem list_: maintained as one or more Evaluations which themselves are generated by clinicians as a rsult of observations made elsewhere in the record;
* _Medications list_: derived from Instructions and Actions in the record. The status of Actions allows medications to be displayed as past, current, suspended etc.
* _Therapeutic precautions (allergies and alerts)_: recorded as Evaluations of various kinds (adverse reactions are essentially a kind of diagnosis);
* _Patient preferences_: recorded as Evaluations (since they act like contra-indications for certain drugs or treatments);
* _Patient consents_: recorded as instances of Admin_entry;
* _Family history_:
** actual events / conditions in family members are recorded as Observations (e.g. father died of MI at 62)
** patient risks are expressed using Evaluations, often including family history reasons.
* _Social history/situation_: current and previous social situation (e.g. in nursing care, details of feeding, sleeping arrangments) are documented as Observations.
* _Lifestyle_: there are various Observation archetypes for recording aspects of lifestyle, including exercise, smoking/tobacco, alcohol, drug use and so on.
* _Vaccination record_: vaccinations are a kind of Instruction; vaccinations that have actually been given are available as Actions in the record.
* _Care plan_: combinations of goals, targets (Evaluations), monitoring, education (Instructions), etc orgnanised in a care plan Section hierarchy.

The remaining vast majority of remaining clinical information is recorded inside event Compositions,
and includes the following:

* _laboratory results_ including imaging: recorded as Observations;
* _physical examinations_: recorded as Observations appointment, admission and discharge: recorded as Admin_entry
* _prescriptions_: one or more medication orders (each one is an Instruction) within a prescription Section structure, within a prescription Composition.
* _referrals_: recorded as Instructions (i.e. a request for care by another provider).

The above concepts are defined in terms of archetypes of Entry and other reference model types in openEHR; their definition is therefore completely separate from the reference model.

=== Demographic Data in the EHR

The general approach of openEHR is to enable the complete separation of demographic (particularly patient-identification information) from health records, both in the interests of privacy (in some cases required by national legislation) and separated data management. The Demographic IM therefore defines demographic information. However, there is nothing to prevent certain demographic information occurring in the EHR, and in some cases this is desirable. The two main cases for this are:

* clinically-relevant patient information, such as age, sex, height, weight, eye-colour, ethnicity or 'race', occupation;
* identifiers and/or names of health care provider individuals and organisations may be stored directly in the EHR, regardless of whether there is also more detalied information about such entities in the demographic system.

The model of all information intended for a separate openEHR demographic service (itself usually a front-end to an existing hospital master patient index or similar) is defined in the openEHR Demographic Information Model.

== Entry and its Subtypes

The Entry model is defined by the `composition.content.entry package`, shown in the UML diagram below. The choice of subtypes of `ENTRY` is based on the ontology shown in <<CIR_ontology>> and its associated model. The names do not coincide exactly however, for a number of reasons. Firstly, the category names in the hierarchy were chosen based on a philosophical/scientific model of investigation, and reflecting linguistic norms for the meanings of the terms, whereas the class names used here reflect common health computing and clinical usage of these terms (i.e. names which will make sense to software developers in the health arena). Names in these two cultures do not always coincide. Additionally, for categories such as Opinion and Instruction, the subcategories shown in the ontology (e.g. Assessment, Goal and Plan) are too variable to safely be subtyped in software, and are distinguished only at the archetype level. Only a single class for each of these ontological groups is used in the formal model. The use of different names and a slightly simplified mapping has not however prevented the faithful implementation of the semantics of the model. The model classes are described in the following subsections.

[.text-center]
.rm.entry package
image::{uml_diagrams_uri}/RM-composition.entry.svg[id=rm_entry, align="center"]

=== The Entry class

All Entries have a number of attributes in common. The language and encoding attributes indicate how all text data within the Entry are to be interpreted linguistically and at the character set level. Normally, the language will be the same throughout the entire Entry (if not Composition), but in cases where it is not, the optional language attribute of `DV_TEXT` can be used to override the value in the enclosing `ENTRY` (or other enclosing structure, if a `DV_TEXT` is being used in some other context). Character encoding can be overridden in the same fashion by the encoding attribute within `DV_TEXT`.

The other attributes common to all Entry subtypes are as follows:

* `_subject_`: this attribute records the subject of the Entry as an instance of a subtype of `PARTY_PROXY`. When this is the record subject, (i.e. the patient), the value is an instance of `PARTY_SELF`. Otherwise it is typically a family member, sexual partner, or other acquaintance of the record subject. It could also be an organ donor. The latter is expressed in the form of a `PARTY_IDENTIFIED` or `RELATED_PARTY` instance, which describes the kind of relationship, and optionally, identifies the demographic entity.
* `_subject_is_self_`: convenience function returning True when the Entry is about the subject of the record.
* `_provider_`: the agent who provided the information. This is usually the patient or the clinician, but may be someone else, or a software application or device. If participation details of the provider (e.g. mode of communication) need to be recorded, the details should be recorded once in the `EVENT_CONTEXT`.`_participations_`. The provider attribute is optional, since it is often implicit in the information that was recorded.
* `_other_participations_`: other participations which existed for this Entry, e.g. a nurse who administered a drug in an `INSTRUCTION`; only required in cases where participants other than the subject of the information and the provider of the information need to be recorded.

Note that the term 'provider' as used here should not be confused with the more specific healthcare term used in many english-speaking countries meaning 'health care provider', which is usually understood to be a physician or healthcare delivery enterprise such as a hospital. In the model here, it simply means 'provider of information' in the context of an Entry. The information provider is optional, and in many cases will not be recorded, since it will be obvious from the `_composer_` and `_other_participations_` of the enclosing Composition. In many cases, it is not sensible to record a provider, e.g. in the most mundane case where a GP asks "where does it hurt" and the patient says "here" - in such cases, it can only be considered mutual. It is expected to be used only when the composer of the Composition really needs to specify the origin of specific statements, such as in the following circumstances:

* the information provider is specifically accountable for the Entry data (it is their opinion, their decision, they carried out the test etc) - they might also need to attest it;
* the information provider is an authoritative source, or has provided information from a unique perspective (e.g. the view of a spouse/ carer on the patient's functional health status or mental state);
* the information provider's view might not reflect the consensus (e.g. a patient opinion not held by the composer, a difference between father and mother on a description of a child's sleeping pattern);
* the information provider is not one of the Composition-level participants (e.g. an outside information provider such as someone telephoned during the encounter to provide a lab result, or an automated measurement device, or a decision support software component).

=== Care_entry and Admin_entry

A basic division occurs between clinical and non-clinical information. The `CARE_ENTRY` class is an abstract precursor of classes that express information of any clinical activity in the care process around the patient, while `ADMIN_ENTRY` is used to capture administrative information. The division may occasionally seem ambiguous at a theoretical level, but at a practical level, it is almost always clear. Administrative information has the following characteristics:

* it is created by non-clinical staff, or clinical staff acting in an administrative capacity (e.g. a nurse or doctor who has to fill out an admission form in A&E);
* it expresses details to do with coordinating the clinical process, by recording e.g. admission information (enables clinical staff to know who is in the hospital and where they can be found), appointments (ensuring patient and physician get together at an agreed time and place), discharge/dismissal (allowing clinical staff to know that a patient has been sent home healthy, or transferred to another institution), billing and insurance information (where such information is required in the EHR; it may well be in its own system);
* removing administative information from the EHR would not compromise its clinical integrity, it would simply mean that carers and patients would no longer know when and where they were supposed to meet, or when the patient has entered or left a health care facility.

Conversely, every instance of a `CARE_ENTRY` subtype is clinically significant, even if it also carries information which might be of interest to other health management functions billing (e.g. ICD10 coded diagnoses), practice management (e.g. date, time and place in an order for day surgery). The `CARE_ENTRY` type includes two attributes particular to all clinical entries, namely protocol and guideline_id.

These attributes allow the "how" and "why" aspects of any clinical recording to be expressed. Protocol is often recorded for Observations (e.g. staining method in microscopy) and Instructions.

=== Observation

Instances of the `OBSERVATION` class record the observation of any phenomenon or state of interest to do with the patient, including pathology results, blood pressure readings, the family history and social circumstances as told by the patient to the doctor, patient answers to physician questions during a physical examination, and responses to a psychological assessment questionnaire. Observations are distinguished from Actions in that Actions are interventions whereas Observations record only information relating to the situation of the patient, not what is done to him/her.

The significant information of an Observation is expressed in terms of "data", "state" and "protocol". The first of these is recorded in the data attribute, defined as follows:

* `_data_`: the actual datum being recorded; expressed in the form of a History of Events, each of which can be a complex data structure such as a List, Table, Single (value), or Tree, in its own right. Examples include blood pressure, heartrate, ECG traces.

State information can be recorded in the state attribute of Observation, or within the state attribute of each Event in the Observation data attribute (see below and also Data Structures IM for more detailed explanations). The state attribute in Observation is defined as follows:

* `_state_`: any particular information about the state of the subject of the Entry necessary to correctly interpret the data, which is not already known in the health record (i.e. facts such as the patient being female, pregnant, or currently undergoing chemotherapy). For example, exersion level (resting, post-marathon...), position (lying, standing), post- glucose challenge, and so on. The form of the `_state_` attribute is the same as that of the `_data_` attribute: a `HISTORY` of `EVENT` of `ITEM_STRUCTURE`.

The inherited protocol attribute is defined as follows:

* `_protocol_`: details of how the observation was carried out, which might include a particular clinical protocol (e.g. Bruce protocol for treadmill exercise ECG) and/or information about instruments other other observational methods. This information can always be safely omitted from the user interface, i.e. has no bearing on the interpretation of the data.

The detailed semantics of Observation data are described in the following subsections.

==== Timing in Observations

Many health information models express observation time as one or more attributes with names like 'observation_time', 'activity_time' and so on. The openEHR model departs from this by modelling historical time inside a History/Event structure defined in the `data_structures.history` package. In short, this package defines the `HISTORY` class with an origin attribute, and a series of `EVENT` instances each containing a time attribute. Instantaneous and interval events are distinguished via the `EVENT` subtypes `POINT_EVENT` and `INTERVAL_EVENT`; interval events have the width attribute is set to the duration of the interval.

==== Valid Contents of a History

One of the aims of the model of Observation described here is to represent in the same way single sample and multi-sample time-based data for which measurement protocol is invariant. It is not intended for measurements in "coarse" time taken by different people, different instruments, or with any other difference in data-gathering technique. In these cases, separate, usually single-sample histories are used, usually occurring in distinct container objects (e.g. distinct Compositions, in the EHR).

Accordingly, in the general practice setting, the use of `HISTORY` will correspond to measurement series which occur during the clinical session (i.e. during a patient contact). In a hospital setting, nurses' observations might occur in 4-hourly intervals, and there is no well-defined clinical session - simply a series of `ENTRYs` during the time of the episode. Two approaches are possible here.

* If each Observation is to be committed to the EHR as soon as it is made, the result will be distinct `COMPOSITIONs` in time, each with its event_context corresponding to the period of the nurse's presence. Each Composition will contain one or more Observations, each containing in their data a History of one sample of the measured vital sign.
* If Observations are not committed to the EHR immediately, but are stored elsewhere and only committed (say) at the end of each day, then the result will be a single Composition whose event_context corresponds to the total data gathering period, and which contains Observations whose data are multi-event Histories representing the multiple measurements made over the day.

Whether time-based data remain outside the record until a series of desired length is gathered, or entered as it occurs is up to the design of applications and systems; the approach taken should be based on the desired availability of the data in the system in question. If for example, it must be visible in the EHR as soon as the appropriate Compositions are written, then it should be represented as Histories in each relevant Composition; if it need only be available at some much later point in time (e.g. because it is known that no-one but the treating clinician is interested in it), then it can be stored in another system until sufficient items have been gathered for committal to the EHR.

==== Clinical Semantics of Event Time
In most cases, the times recorded in a History (`HISTORY`.`_origin_` and `EVENT`.`_time_`, `_width_`) can be thought of as "the times when the observed phenomena were true". For example, if a pulse of 88bpm is recorded for 12/feb/2005 12:44:00, this is the time at which the heartrate (for which pulse is a surrogate) existed. In such cases, the sample time, and the measuring time are one and the same.

However in cases where the time of sampling is different from that of measurement, the semantics are more subtle. There are two cases. The first is where a sample is taken (e.g. a tissue sample in a needle biopsy), and is tested later on, but from the point of view of the test, the time delay makes no difference. This might be because the sample was immediately preserved (e.g. freezing, placed in a sterile anaerobic transport container), or because even if it decays in some way, it makes no difference to the test (e.g. bacteria may die, but this makes no difference to a PCT analysis, as long as the biological matter is not physically destroyed).

The second situation is when the sample does decay in some way, and the delay is relevant. Most such cases are in pathology tests, where presence of live biological organisms (e.g. anaerobic bacteria) is being measured. The sample time (or 'collection' time) must be recorded. Depending on when the test is done, the results may be interpreted differently.

The key question is: what is the meaning of the `HISTORY`.`_origin_` and `EVENT`.`_time_` attributes in these situations? It is tempting to say that their values are (as in other cases) just the times of the actual act of observation, e.g. microscopy, chromatography etc. However, there are two problems with this. Firstly, and most importantly, all physical samples must be understood as being _indirect surrogates for some aspect of the patient state_ at the time of sampling, which cannot be observed by direct, instantaneous means in the way a pulse can be taken. This means that no matter when the laboratory work is done, the time to which the result applies is the sample time. It is up to the laboratory to take into account time delays and effects of decay of samples in order to provide a test result which correctly indicates the state of the patient at the time of sampling. The common sense of this is clear when one considers the extreme case where the patient is in a coma or dead (possibly for reasons completely unrelated to the problem being tested for) by the time laboratory testing actually occurs; however, the test result indicates the situation at the point in time when the sample was taken, i.e. when the patient was alive. The second reason is that some kinds of testing are themselves lengthy. For example fungal specimens require 4-6 weeks to confirm a negative result; checks will be made on a daily or weekly basis to find positive growth. However, the result data reported by the laboratory (and therefore the structure of the Observation) is not related to the timing of the laboratory testing; it is reported as being the result for the time of collection of the specimen from the patient. 

The meaning therefore of the `HISTORY`.`_origin_` and `EVENT`.`_time_` attributes in openEHR is always the time of sampling. Where delays between sample and measurement times exist and are significant, they are noted in the protocol section of the Observation; such times are modelled in the appropriate archetypes, and taken into account in results.

==== Two ways of Recording State

State information is optional, and is not needed if the data are meaningful on their own. If it is recorded, it can either be as a History of its own (i.e. using the `OBSERVATION`.`_state_` atttribute described above), or else as state values within the `EVENT` instances in the `OBSERVATION`.`_data_` History. Both methods are useful in different circumstances. A separate state history is more likely to be used in a correlation study such as a sports medicine study on heartrate with respect to specific types of exercise. In this method, the state information is a History of Events whose times and widths need not match those of the History in the data attribute. The state data under this approach generally express the condition of the subject in absolute terms, i.e. they are standalone statements about the subject's state at certain points in time, such as "walking on treadmill 10km/h, 10^o^ incline". 

The other method will be used in most general medicine, e.g. for recording fasting and post glucose challenge states of a patient undergoing a glucose tolerance test. (See the Data Structures Information Model for more details). State values stored within the `_data_` History represent the situation in the subject at the time of the Event within the History and usually in relation to it, for example "post 8 hour fast". Recording the latter example in an independent state History would require an Event of 8 hours' duration called 'fast'. The latter would be technically still correct, but would be very unnatural to most clinicians. The figure below illustrates the two methods of recording state.

[.text-center]
.Alternative ways of recording state
image::{diagrams_uri}/recording_state.png[id=recording_state, align="center", width=65%]

=== Evaluation

According to the ontology described in citenp:[Beale_Heard2007], the Opinion category covers a number of concrete concepts, as follows.

* _problem/diagnosis_: the assignment of a known diagnosis or problem label to a set of observed signs and symptoms in the patient, for the purpose of determining and managing treatment. The physician will usually include a date of initial onset, date clinically recognised, date of last occurrence, date of resolution of last occurrence and possibly other timing information.
* _risk assessment_: an evaluation of the likelihood and timing of a certain event occurring or condition appearing.
* _scenario_: an opinion about the outcome if a certain intervention is proceeded with.
* _goal_: statement of a target, and a time at which it should be reached. 
* _recommendation_: a description in general terms of a suggested care approach for the patient, based on diagnosis; includes various times or time-periods for activities, such as monitoring, taking of medications, and review.

The approach taken to modelling these concepts in openEHR is heavily based upon the development of archetypes for assessments such as "diagnosis" (various kinds), "goal", "adverse reactions", "alert", "exclusion", "clinical synopsis", "risk based on family history" and so on. Experience has shown that the Opinion category is too variable for safely modelling its sub-categories directly in the reference model. Instead, a single class `EVALUATION` is used for all instances of the Opinion category. (The name Evaluation has been present in openEHR for some years, and is retained for reasons of continuity).

The design of the `EVALUATION` class is very simple. In addition to the attributes inherited from `ENTRY` and `CARE_ENTRY`, it has only one attribute, `_data_`: `ITEM_STRUCTURE`. This structure is intended to be archetyped so as to model all the details of any particular clinical information in the Opinion category. No timing attributes are included, since there is no time associated with creation or capturing of Evaluation information as such, only times included in the information. The only times of generic significance are (potentially) the time of a patient consultation during which the Evaluation was created (recorded in `COMPOSITION`.`_event_context_`.`start_time_` and `_end_time_`) and the time of committal to the EHR system (recorded in `VERSION`.`_commit_audit_` attribute).

The general meaning of the inherited attributes is as for all Entries. In Evaluations, the provider is almost always the physician, while the protocol may be used to indicate how a particular assessment was made. The other_participations attribute is not as likely to be used for Evaluations representing diagnoses, since a diagnosis is usually the result of thinking on the part of the physician; an exception to this would be a case conference or if an expert system were used. However, Plans for complex patients may well be constructed by multiple physicians.

=== Instruction and Action

Instructions in openEHR specify actions to be performed in the future. They differ from information in the Proposal sub-category of Opinion in the ontology (i.e. instances of Evaluation in the class model) in that they are specified in sufficient detail to be directly enacted without further clinical decision-making related to the design of the Instruction, e.g they can be performed by the patient or a nurse. Any decisions that could be made during the performance of an Instruction are either constrained by the Instruction itself (e.g. dose range; suspend if adverse reaction) or else are assumed knowledge of the expected performer. For example, an Evaluation may say that "oral cortico-steroids are indicated at a peak flow of 200 l/m". A corresponding Instruction would indicate the actual drug, route, dose, frequency, and so on. The informed patient might be reasonably expected to be able to vary the dosage on his or her own within a dosage guideline explained by his/her GP.

In the ontology shown in figure <<CIR_ontology>>, Instructions are further categorised as Investigation and Intervention. However, as for Evaluation, only a single key class, `INSTRUCTION`, is used to model all types of the Instruction category, with archetypes defining the details of the Instruction. A second Entry subtype, `ACTION`, is used to model the information recorded due to the execution of an Instruction by some agent.

The following subsections describe Instruction and Action in some detail.

==== Requirements

The Instruction and Action classes are designed to satisfy the following requirements:

* All kinds of interventions, from simple medication orders to complex multi-drug courses should be representable using the same model;
* Instructions should always have a narrative expression, with an optional machine-processible expression in cases where automation will be used;
* The freedom must exist to model any particular intervention in as much or little detail as required by circumstances;
* Clinicians must be able to specify Instruction steps in their own terms, i.e. using terms like "prescribe", "dispense", "start administering", etc;
* Instructions representing diverse clinical workflows must be queryable in a standard way, so that it can be ascertained what Instructions are 'active', 'completed' and so on for a patient;
* It should be possible to provide a coherent view of the state of execution of an Instruction even if parts of it have been executed in different healthcare provider environments;
* It must be possible to record ad hoc actions in the record, i.e. acts for which no Instruction was defined (at least in the EHR in question);
* Instructions must integrate with notification / alert services;
* An interoperable expression of computable workflow definitions of Instructions will be supported.

==== Design Principles

The design approach is based on four principles. The first is that the _specification_ of an Instruction as one or more Activities is distinguished from the information representing actions performed as a result. This makes the model and resulting information instances clear to software designers and data users. It also enables workflow engines to determine which parts of the specification have already been executed, and allows for Actions actually performed to differ from those specified. The separation is realised in terms of the `INSTRUCTION` and `ACTION` classes and their helpers. Instances of the former specify an Instruction, while instances of the latter describe steps which have actually been performed.

The second principle is the use of a standard instruction state machine (ISM) defining standardised states and transitions for each Activity of an Instruction, no matter what its clinical meaning. The use of standardised states means that the execution state of any given Activity can be characterised in exactly the same way (e.g. 'planned', 'active', etc), and that it is therefore possible to query the EHR and find out all interventions of any kind in a particular state. The ISM is formally modelled in openEHR. The Instruction itself can also be considered to be in a state derived from the states of its Activities. An informal description of this aggregate state machine is given below. 

The third principle is to provide a way of mapping steps in any care pathway process (i.e. healthcare business process) to states in the Instruction state machine. A care pathway process covers the entirety of steps required to effect an Instruction, for example prescribing, booking, dispensing, referring, suspension etc. Any such step when performed leaves the relevant Instruction in one of the states of the ISM.

The fourth principle is to support the expression of the formal workflow definition for an Instruction, where full automation is required. It must be recognised that automation of most therapies and drug admnistration, as well as other interventions like biopsies is minimal today, and is likely to remain so for some time. This is for the simple reason that the cost of automating most tasks is prohibitive compared to human execution, particularly when Instruction activities can often be executed by healthcare professionals already present for other reasons (e.g. ward nurses). It also has to be said that serious research into the use of workflow automation in healthcare is only quite recent, and that so far, there are no standard models for clinical workflow. In the openEHR approach to modelling workflow, such uncertainty is dealt with in two ways. Firstly, formal workflow specification of an Instruction is an optional addition to the base model of Instruction and Action classes, and is not required to obtain a basic level of computability, including use of the ISM. Secondly, the formal expression of workflow is in the form of parsable syntax rather than objects. This is a generally appropriate design choice, since the safest and most convenient persistent form of of a complex formalism is the syntax form rather than the parsed fine-grained object form; this both optimises storage and allows for changes in the syntax over time.

==== Model Overview

Instruction definitions are modelled in terms of the `INSTRUCTION` and `ACTIVITY` classes, with optional workflow attributes. These two classes carry the basic information relating to an Instruction, with all formal workflow definition expressed in parsable syntax in the `INSTRUCTION`.`_wf_definition_` attribute. An `INSTRUCTION` instance includes the narrative description of the Instruction, and a list of `ACTIVITY` instances. It also includes all the attributes inherited from the `CARE_ENTRY` class, including subject, participations and so on.

Many Instructions will have only one Activity, usually describing a medication to be administered and its timing. Some will have more than one drug or therapy, such as the typical 3 drug Losec-HP regime for treating ulcers, and multi-drug chemotherapy. The base Instruction model does not explicitly try to indicate the exact order, serial or parallel administration, or other dependencies, since the knowledge of how to administer the drugs is known by the relevant clinicians, and/or contained in published guidelines. However, the timing information in each Activity does indicate times, days and the usual specifications of "with meals" etc. The timing information is also sufficient to specify a three drug chemotherapy regime, by indicating which days each drug is administered on. It is only when the Instruction is to be automated by a workflow engine that the full structure of the Activity graph will be given. Activity instances may be completely absent from an Instruction, in which case only the narrative will be present. This will typically occur with imported legacy data which itself has no structured representation of medications.

There are three possible levels of representation of an Instruction, as shown in the figure below. These are the minimal narrative-only level, a level with formal representation of Instruction activities by `ACTIVITY` instances, and a level where a formal workflow definition can also be used. It is expected that the vast majority of openEHR systems for the forseeable future will support only the minimal and basic levels.

[.text-center]
.Levels of Instruction representation
image::{diagrams_uri}/instruction_representation.png[id=instruction_representation, align="center", width=60%]

The following figure illustrates the correspondence between Instruction and Activity structures, and Action objects that are created due to executing the instructions. Each Activity has a standard Instruction State Machine logically associated with it, indicated in blue. When any step in an Instruction Activity is executed within an ICT-supported environment, an `ACTION` instance describing what was done should be created and committed to the EHR. In some cases, ad hoc Actions are created even when there is no Instruction, such as by self-medicating patients and nurses reacting quickly to patient changes. For such Actions, there is always a notional Activity understood by the health professional.

[.text-center]
.Correspondence of Actions to Instructions
image::{diagrams_uri}/actions_and_instructions.png[id=actions_and_instructions, align="center", width=70%]

All `ACTIONs` include the inherited `CARE_ENTRY` attributes, along with the time of being performed, a description of what was performed, and an `ISM_TRANSITION` object indicating the state of the Activity (whether explicit in an Instruction or not). The current state of an Activity is thus found not in the `ACTIVITY` instance but in the most recent `ACTION` instance for that Activity. 

If the Action did correspond to an Instruction, it will also include an `INSTRUCTION_DETAILS` instance, which indicates which Activity of which Instruction was executed, including workflow execution details if relevant.

Under this scheme, the state of each intervention happening to the patient can be ascertained by querying, regardless of whether explicit Instructions exist. 

Note particularly that Actions are often performed in a different provider location, or the home, rather than the provider organisation responsible for the Instruction. Action objects for a given Instruction can thus easily appear in multiple health record systems.

==== The Standard Instruction State Machine (ISM)

When an intervention defined by an Activity is unfolding in a clinical context, EHR users want to know things such as the following:

* what is the current step in the Activity for the patient?
* for a given patient, what Activities are planned, active, suspended, completed?
* for the populations of patients, what is the state of a particular workflow, such as a recall, for each one?

The approach chosen here to support such functionality is to define a standard instruction state machine whose state transitions can be mapped to the steps of a specific care pathway, enabling it to be used as a descriptive device for indicating the state of any Activity. The state machine is illustrated below. 

[.text-center]
.openEHR standard Instruction State Machine
image::{diagrams_uri}/instruction_state_machine.png[id=instruction_state_machine, align="center"]

This state machine is the result of long term experience with clinical workflows and act management systems. The states are as follows (Note: the SCHEDULED state was inspired by citenp:[Van_de_Velde_Degoulet2003], Fig 5.5).

[horizontal]
INITIAL:: initial state, prior to planning activity (default starting state for computable representation of state machine).
PLANNED:: the action has been described, but has not as yet been performed.
POSTPONED:: the action has not been performed and will not without specific conditions being met. Specifically, events and conditions that would normally 'activate' the instruction will be ignored, until a restore event occurs.
SCHEDULED:: the action will be performed at some designated future time, and has been booked in a scheduling system.
CANCELLED:: the action was defined, but was cancelled before being performed.
ACTIVE:: the action is being performed according to its definition. The entire course of medication or therapy corresponds to this state.
SUSPENDED:: the action was begun, but has been stopped temporarily, and will not be restarted until explicitly resumed.
ABORTED:: the action began but was permanently terminated before normal completion.
COMPLETED:: the action began and was completed normally.
EXPIRED:: the time during which the action could have been relevant has expired; the action may have completed, been cancelled, or never occurred.

States `CANCELLED`, `ABORTED` and `COMPLETED` are all terminal states. The `EXPIRED` state is a pseudo-terminal state, from which transitions are allowed to proceed to any of the true terminal states, due to information being received after the fact (such as a patient reporting that they did indeed finish a course of antibiotics). However it is likely in the EHR that Instructions for many simple medications will finish in the `EXPIRED` state and remain there.

The transitions are self-explanatory for the most part, however a few deserve comment. The start and finish events correspond to situations when the administration is not instantaneous, as is the situation with most medications. The do event is equivalent to the finish event occurring immediately after the start event, corresponding to an instantaneous administration, completion of which puts the Activity in the completed state. A single shot vaccination or patient taking a single tablet are typical examples. The states `PLANNED`, `POSTPONED`, `ACTIVE`, `SUSPENDED`, each have a `xxx_step` transition which return the state machine to the same state. Workflow steps that cause no transition are mapped to these events and thus leave the Instruction in the same state. An example is a medication review, which will leave the medication in the `ACTIVE` state, if the physician chooses to continue.

In the future, if delegation of an Instruction to another Instruction is required, nesting of a new Instruction state machine within the Active state of a previous one might need to be supported.

The state machine states and transition names are defined in the openEHR terminology groups "Instruction states" and "Instruction transitions" respectively.

==== Instruction Aggregate State

Each Activity within an Instruction constitutes a clinically identifiable medication or therapy of some kind, while the Instruction usually corresponds to a grouping or combination of therapies designed to treat an overall problem. Accordingly, the Instruction can be seen as having an aggregate state derived from the states of the Activities, as shown in the figure below. The rules for entering each aggregate state are indicated in terms of the states of the constituent Activities.

[.text-center]
.Aggregate Instruction state
image::{diagrams_uri}/aggregate_instruction_state.png[id=aggregate_instruction_state, align="center", width=70%]

This state machine is not formally modelled or coded in openEHR, although it may be useful to do so within an application.

==== Careflow Process to State Machine Mapping

From a health professional's point of view, a healthcare workflow, or 'careflow', consists of steps and events designed to meet one or more goals. The steps are highly dependent on the particular kind of workflow, and will usually be named in terms familiar to the relevant kinds of clinical professionals, such as "prescribe", "book", "suspend" and so on (note that some of these names may be the same as ISM transitions, but may or may not indicate the same thing). However, the need of users of health information is to know what state the execution of an Instruction is in, regardless of which particular careflow step might have just been executed. This is achieved by defining the mapping between the steps of a particular careflow to the states of the ISM in an Action archetype. When each Action corresponding to a particular Instruction Activity is performed, it will be known both which careflow step it corresponds to and which ISM state the Activity is now in. The following table provides an example of the mapping for a UK GP medication order workflow.

[cols="1,2", options="header", width=50, align="center"]
|===
|UK GP +
 Workflow Step
|State machine transition

|Start      |initiate (initial -> planned)
|Prescribe  |planned_step (planned -> planned)
|Dispense   |start (planned -> active)
|Administer |active_step (active -> active)
|Request    |Renewal active_step (active -> active)
|Re-issue   |active_step (active -> active)
|Review     |active_step (active -> active)
|Finish     |finish (active -> completed)
|Cancel     |abort (active -> aborted)

|===

Mappings like this are specified in the archetypes for the Instruction. When an `ACTION` instance is committed to the EHR, the `ISM_TRANSITION` object records the step performed and the ISM state and transition. The careflow step must be one of the steps from the corresponding Instruction. The following section provides details of how archetypes are used to represent such mappings.

==== Relationship to Archetypes

Much of the semantics of particular Instructions and Actions derive from archetypes. Currently, archetypes are used to define two groups of Instruction semantics. The first is the descriptions of activities that are defined in Instructions (`ACTIVITY`.`_description_`) and executed in Actions (`ACTION`.`_description_`). These descriptions are always of the same form for any given Instruction, and it is highly desirable to have the same archetype component for both. An example is where the description is of a medication, commonly consisting of a tree or list of ten or more elements describing the drug, its name, form, dose, route and so on. The same information structure is needed in the Instruction, where it defines what is to be administered, and in the Action, where it describes what has been administered. In any particular instance, there may be small differences in what was administered (e.g. dose or route are modified) even though the archetype model will be the same for both.

In terms of archetypes therefore, definition of say two `ACTIVITIEs` in an `INSTRUCTION` (see example illustrated below) will actually create separate archetypes of the Activity structures, each of which will be one of the subtypes of `ITEM_STRUCTURE` (since this is the type of `ACTIVITY`.`_description_` and `ACTION`.`_description_`). The archetypes will then be used by both the `INSTRUCTION` archetype and the `ACTION` archetype, via the archetype slot mechanism (i.e. the standard way of composing archetypes from other archetypes; see `use_archetype` statements in the figure below).

[.text-center]
.Instruction and Action Archetypes
image::{diagrams_uri}/instruction_and_action_archetypes.png[id=instruction_and_action_archetypes, align="center", width=70%]

The second category of archetypable semantics is the correspondence between steps in a healthcare business process and the standard instruction state machine, as described above. This mapping is an archetype of the ism_transition attribute of an `ACTION` attribute, and therefore defines part of the `ACTION` archetype. <<instruction_and_action_archetypes>> shows how logical archetype elements in the archetyped editor environment corresponds to the resulting archetypes.

=== Clinical Workflow Definition

Clinical workflows exist at multiple hierarchical levels, from the health system level (reduce diabetes costs; manage obesity) to the fine-grained (asthmatic medication prescription for a particular patient). At all levels, there are goals, actors and tasks designed to satisfy the goals. At a coarse-grained business process level, workflows may be enacted by more than one actor, and may encompass the whole cycle of Observation, Diagnosis, Instruction and Action. For example a workflow describing the steps "prescribe", "dispense", "administer", "repeat", "review" and so on, around a medication order might include GP, pharmacist, patient as actors. At the finer level of an actual drug or therapy administration, there is usually a single agent or group that performs a specific task, usually within one provider institution, or at home. The correspondence between workflows at these different levels and particular patients, rather than just categories of patients (e.g. all insulin-dependent diabetics), typically increases at finer levels of granularity. Thus from the point of view of automation, it is likely to be fine-grained workflows that have patient-specific definitions which would reasonably appear in the EHR. Most typical medication administrations are in this category. How automated workflow definitions at higher levels of organisational hierarchy are represented and coordinated with lower-level automated workflows is known to be a difficult problem generally, and given that health computing is generally more complex than most domains, implementation of distributed, coordinated (or "orchestrated" or "choreographed", to use the terms of the workflow community) clinical workflows is likely to be some years off.

In this context, the possible scope for formal workflow definition in openEHR appears to be as follows:

* To enable the recording of links between openEHR Entries and workflow executions, e.g. a particular guideline. This allows openEHR data to be integrated with coarse-grained nonpatient specific workflows.
* To support a standardised, interoperable representation of fine-grained formal workflow definitions for activities like medication administration.
* To use formal workflow definitions only where automation is actually useful, and is likely to be used. The kind of workflows that are likely to be worth automating are those which run over several days, weeks or longer, i.e. where humans might easily forget to perform a step. In these cases, the output of the workflow system will be reminders for humans to do certain things at certain times, rather than direct machine automation of the task. Execution of such workflow definitions will generate entries in "worklists" for staff or other agents to perform. Examples include asthma drug management for a child and PAP recall management.
* To ensure that any workflow definition takes account of other existing clinical activities, i.e. does not attempt to define all activities that might possibly be relevant. A simple example is a workflow for asthma medication administration probably does not need to explicitly model the taking of peak flow measurements, since this would normally be occurring anyway.

There are various technical challenges with proposing a standard workflow formalism for clinical use. Firstly, executable workflow definitions are essentially structured programs, similar to programs in procedural languages, but with the addition of temporal logic operators, including alternative paths, parallel paths, wait operations, and also references to outside data sources and services. Recent work in clinical workflow modelling e.g. citenp:[Müller2003], citenp:[Barretto2005], citenp:[Browne2005] appears to favour a structural (i.e. parse-tree) approach to representation, due to the need to compute potential modifications to an executing workflow, including dropping, replacing and moving nodes. (Whether such "live" modification of executing workflows is realistic from the designer's point of view might be questionable, since it means that the design of each workflow has include every possible exceptional case at a detailed level.)

Secondly, the need to connect workflows to the outside world, i.e. data sources and services like notification and worklist management is crucial in making workflows and guidelines implementable. This problem is probably the main weakness of all guideline and workflow languages to date, including Arden, GLIF, and the various workflow languages such as those mentioned earlier.

The approach taken by the current release of openEHR in representing computable workflow is the following.

* Where used at all, formal workflow definitions are expressed in terms of syntax, not structures, since syntax is always a more appropriate representation for persistence (just as object structures, i.e. parse trees are more appropriate for computation).
* Access to patient data items are expressed within the syntax as symbolic queries.
* Actions, such as requests to the notification service are represented as symbolic commands.

The entire definition of a workflow is expressed as an optional parsable string, in the wf_definition: `DV_PARSABLE` attribute of the `INSTRUCTION` class. Any syntax may currently be used. A workflow syntax is under development by the openEHR Foundation, which is designed to incorporate the relevant features of current workflow models and research, while integrating it into the openEHR type system and archetype framework. In particular, early versions of this syntax will show how patient data access and service commands can be expressed.

== Class Descriptions

include::{uml_export_dir}/classes/entry.adoc[]

include::{uml_export_dir}/classes/admin_entry.adoc[]

include::{uml_export_dir}/classes/care_entry.adoc[]

include::{uml_export_dir}/classes/observation.adoc[]

include::{uml_export_dir}/classes/evaluation.adoc[]

include::{uml_export_dir}/classes/instruction.adoc[]

include::{uml_export_dir}/classes/activity.adoc[]

include::{uml_export_dir}/classes/action.adoc[]

include::{uml_export_dir}/classes/instruction_details.adoc[]

include::{uml_export_dir}/classes/ism_transition.adoc[]

== Instance Structures

The following subsections illustrate typical Entry instance structures. For guidance on how to best model particular clinical statements, see the archetype part of the {openehr_CKM}[openEHR Clinical Knowledge Manager repository^].

=== OBSERVATION

==== Heartrate Measurement Series

The following figure illustrates three heartrate measurements over 10 minutes.

[.text-center]
.Periodic series instance structure
image::{diagrams_uri}/periodic_series.png[id=periodic_series, align="center", width=80%]

==== Blood Pressure with Protocol

The following figure illustrates a blood pressure observation with protocol.

[.text-center]
.Blood Pressure Measurement Observation
image::{diagrams_uri}/BP_measurement.png[id=BP_measurement, align="center", width=70%]

==== Glucose Tolerance Test

An oral glucose tolerance test takes the following form, although the number and timing of the blood sugar levels may be slightly different in practice:

* challenge: no calories fasting from 12pm to 8am
* datum: BSL - 8am
* challenge: 75 g glucose orally - 8:01 am
* datum: BSL - 9 am
* datum: BSL - 10 am

OGTT is treated as a single clinical concept, and thus requires only one archetype. A typical instance structure is shown in the figure below. In this example, the three blood sugars are represented by `EVENTs`, with the fasting and glucose challenges being expressed as states on the relevant events.

[.text-center]
.OGTT instance structure
image::{diagrams_uri}/OGTT_structure.png[id=OGTT_structure, align="center", width=80%]

=== EVALUATION

==== Partial Asthma Management Plan

The following figure illustrates a partial asthma management plan in which monitoring (peak flow) with dependent actions (review and admission to ER) and therapy (bronchodilator) are shown. In a complete plan, symptom monitoring and other medications might be shown. The parts of the plan are linked to the root `EVALUATION` node via the `_links_`: `Set<LINK>` attribute inherited from the `LOCATABLE` class.

[.text-center]
.Partial Asthma Management Plan
image::{diagrams_uri}/partial_asthma_plan.png[id=partial_asthma_plan, align="center", width=80%]

=== INSTRUCTION

==== Chained Medication Order

Often, a medication order for one drug consists of segments in which one or more of the administration details of route, form, frequency, dose etc is changed. In hospitals, intravenous antibiotics and pain relief drugs may be followed by a tablet form of the same drug to be taken orally. Other examples are common in general practice, such as the following order:

* trade name = Panafcortelone; generic name = Prednisolone; form = tablets; dose = 25mg; route = oral; freq = bd x 3 days; od x 2 days.

The figure below illustrates the instance structure for this Instruction. Note that the timing attribute of the `ACTIVITY` instance is shown in human-readable form; in reality it will be a GTS string or similar (see Timing Specification section of openEHR Data Types IM).

[.text-center]
.Chained medication order
image::{diagrams_uri}/chained_medication_order.png[id=chained_medication_order, align="center", width=80%]

==== Multi-drug Therapy

A common regime for treating duodenal ulcer and related complaints is using Losec with other drugs, such as in the following combination:

* Losec 40 mg od x 4w or until no symptoms
* amoxicillin 500 mg 3td x 7d
* metronidizole 400 mg 3td x 7d

The Instruction for this therapy is illustrated below.

[.text-center]
.Multi-drug therapy Instruction
image::{diagrams_uri}/multi_drug_therapy_instruction.png[id=multi_drug_therapy_instruction, align="center", width=80%]
